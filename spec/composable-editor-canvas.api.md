## API Report File for "composable-editor-canvas"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="react" />

import type { Draft } from 'immer/dist/types/types-external';
import type { Patch } from 'immer/dist/types/types-external';
import * as React_2 from 'react';
import { default as React_3 } from 'react';
import type { WritableDraft } from 'immer/dist/types/types-external';

// @public (undocumented)
export function AlignmentLine(props: {
    value?: number;
    type: 'x' | 'y';
    transformX?: (p: number) => number;
    transformY?: (p: number) => number;
    style?: React_2.CSSProperties;
}): JSX.Element | null;

// @public (undocumented)
export const allDirections: readonly ["left", "right", "top", "bottom", "left-bottom", "left-top", "right-top", "right-bottom", "center"];

// @public (undocumented)
export const allSnapTypes: readonly ["endpoint", "midpoint", "center", "intersection", "nearest"];

// @public (undocumented)
export interface AngleRange {
    // (undocumented)
    counterclockwise?: boolean;
    // (undocumented)
    endAngle: number;
    // (undocumented)
    startAngle: number;
}

// @public (undocumented)
export interface Arc extends Circle, AngleRange {
}

// @public (undocumented)
export function arcToPolyline(content: Arc, angleDelta: number): Position[];

// @public (undocumented)
export function bindMultipleRefs<T>(...refs: (React.ForwardedRef<T> | React.MutableRefObject<T | null>)[]): (r: T) => void;

// @public (undocumented)
export interface Circle extends Position {
    // (undocumented)
    r: number;
}

// @public (undocumented)
export function CircleArcEditBar(props: {
    x: number;
    y: number;
    r: number;
    startAngle: number;
    endAngle: number;
    scale?: number;
    resizeSize?: number;
    onClick?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: 'center' | 'start angle' | 'end angle' | 'radius', cursor: React_2.CSSProperties['cursor']) => void;
    onMouseDown?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: 'center' | 'start angle' | 'end angle' | 'radius', cursor: React_2.CSSProperties['cursor']) => void;
}): JSX.Element;

// @public (undocumented)
export function CircleEditBar(props: {
    x: number;
    y: number;
    radius: number;
    scale?: number;
    resizeSize?: number;
    onClick?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: 'center' | 'edge', cursor: React_2.CSSProperties['cursor']) => void;
    onMouseDown?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: 'center' | 'edge', cursor: React_2.CSSProperties['cursor']) => void;
}): JSX.Element;

// @public (undocumented)
export function colorNumberToRec(n: number, alpha?: number): [number, number, number, number];

// @public (undocumented)
export function colorStringToNumber(color: string): number;

// @public (undocumented)
export function combineStripTriangleColors(colors: number[][]): number[];

// @public (undocumented)
export function combineStripTriangles(triangles: number[][]): number[];

// @public (undocumented)
export function createWebglRenderer(canvas: HTMLCanvasElement): ((graphics: Graphic[], backgroundColor: [number, number, number, number], x: number, y: number, scale: number) => void) | undefined;

// @public (undocumented)
export function dashedPolylineToLines(points: Position[], dashArray: number[], skippedLines?: number[], dashOffset?: number): Position[][];

// @public (undocumented)
export function deduplicate<T>(array: T[], isSameValue: (a: T, b: T) => boolean): T[];

// @public (undocumented)
export function deduplicatePosition(array: Position[]): Position[];

// @public (undocumented)
export const defaultMiterLimit = 10;

// @public (undocumented)
export function DragMask(props: {
    onDragEnd: () => void;
    onDragging: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>) => void;
    ignoreLeavingEvent?: boolean;
    style?: React_2.CSSProperties;
    children?: React_2.ReactNode;
}): JSX.Element;

// @public (undocumented)
export function drawDashedLine(g: {
    moveTo: (x: number, y: number) => void;
    lineTo: (x: number, y: number) => void;
}, p1: Position, p2: Position, dashArray: number[], startDistance?: number): number;

// @public (undocumented)
export function drawDashedPolyline(g: {
    moveTo: (x: number, y: number) => void;
    lineTo: (x: number, y: number) => void;
}, points: Position[], dashArray: number[], skippedLines?: number[], dashOffset?: number): void;

// @public (undocumented)
export function EditBar<T = void>(props: {
    positions: EditBarPosition<T>[];
    scale?: number;
    resizeSize?: number;
    onClick?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: T, cursor: React_2.CSSProperties['cursor']) => void;
    onMouseDown?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: T, cursor: React_2.CSSProperties['cursor']) => void;
}): JSX.Element;

// @public (undocumented)
export type EditBarPosition<T> = Position & {
    cursor?: React_2.CSSProperties['cursor'];
    data: T;
};

// @public (undocumented)
export type EditPoint<T> = Position & {
    cursor: string;
    update: (content: Draft<T>, props: {
        cursor: Position;
        start: Position;
        scale: number;
    }) => {
        assistentContents?: T[];
    } | void;
};

// @public (undocumented)
export interface Ellipse {
    // (undocumented)
    angle?: number;
    // (undocumented)
    cx: number;
    // (undocumented)
    cy: number;
    // (undocumented)
    rx: number;
    // (undocumented)
    ry: number;
}

// @public (undocumented)
export interface EllipseArc extends Ellipse, AngleRange {
}

// @public (undocumented)
export function EllipseArcEditBar(props: EllipseArc & {
    scale?: number;
    resizeSize?: number;
    onClick?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: 'center' | 'start angle' | 'end angle', cursor: React_2.CSSProperties['cursor']) => void;
    onMouseDown?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: 'center' | 'start angle' | 'end angle', cursor: React_2.CSSProperties['cursor']) => void;
}): JSX.Element;

// @public (undocumented)
export function ellipseArcToPolyline(content: EllipseArc, angleDelta: number): Position[];

// @public (undocumented)
export function EllipseEditBar(props: {
    cx: number;
    cy: number;
    rx: number;
    ry: number;
    angle?: number;
    scale?: number;
    resizeSize?: number;
    onClick?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: 'center' | 'major axis' | 'minor axis', cursor: React_2.CSSProperties['cursor']) => void;
    onMouseDown?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, type: 'center' | 'major axis' | 'minor axis', cursor: React_2.CSSProperties['cursor']) => void;
}): JSX.Element;

// @public (undocumented)
export function ellipsePolarToCartesian(cx: number, cy: number, rx: number, ry: number, angleInDegrees: number): {
    x: number;
    y: number;
};

// @public (undocumented)
export function ellipseToPolygon(content: Ellipse, angleDelta: number): Position[];

// @public (undocumented)
export function equals(a: number, b: number): boolean;

// @public (undocumented)
export function formatNumber(n: number, precision?: number): number;

// @public (undocumented)
export interface GeneralFormLine {
    // (undocumented)
    a: number;
    // (undocumented)
    b: number;
    // (undocumented)
    c: number;
}

// @public (undocumented)
export function getAngleSnapPosition(startPosition: Position | undefined, newPosition: Position, getAngleSnap?: (angle: number) => number | undefined): Position;

// @public (undocumented)
export function getBezierCurvePoints(p1: Position, p2: Position, p3: Position, p4: Position, segmentCount: number): Position[];

// @public (undocumented)
export function getBezierSplineControlPointsOfPoints(points: Position[]): (readonly [{
    readonly x: number;
    readonly y: number;
}, {
    readonly x: number;
    readonly y: number;
}])[];

// @public (undocumented)
export function getCirclesTangentTo2Circles(circle1: Circle, circle2: Circle, radius: number): Position[];

// @public (undocumented)
export function getCirclesTangentTo2Lines(p1Start: Position, p1End: Position, p2Start: Position, p2End: Position, radius: number): Position[];

// @public (undocumented)
export function getCirclesTangentToLineAndCircle(p1Start: Position, p1End: Position, circle: Circle, radius: number): Position[];

// @public (undocumented)
export function getColorString(color: number, alpha?: number): string;

// @public (undocumented)
export function getContentByClickPosition<T>(contents: readonly T[], position: Position, contentSelectable: (path: number[]) => boolean, getModel: (content: T) => {
    getCircle?: (content: T) => {
        circle: Circle;
        fill?: boolean;
    };
    getGeometries?: (content: T, contents: readonly T[]) => {
        lines: [Position, Position][];
        regions?: {
            points: Position[];
        }[];
    };
    canSelectPart?: boolean;
} | undefined, part?: boolean, contentVisible?: (content: T) => boolean, delta?: number): number[] | undefined;

// @public (undocumented)
export function getContentsByClickTwoPositions<T>(contents: readonly T[], startPosition: Position, endPosition: Position, getModel: (content: T) => {
    getCircle?: (content: T) => {
        circle: Circle;
        bounding: TwoPointsFormRegion;
    };
    getGeometries?: (content: T, contents: readonly T[]) => {
        lines: [Position, Position][];
        bounding?: TwoPointsFormRegion;
        regions?: {
            points: Position[];
            lines: [Position, Position][];
        }[];
    };
} | undefined, contentSelectable?: (index: number[]) => boolean, contentVisible?: (content: T) => boolean): number[][];

// @public (undocumented)
export function getDefaultZoomOption(options?: Partial<ZoomOptions>): {
    min: number;
    max: number;
};

// @public (undocumented)
export function getEllipseAngle(p: Position, ellipse: Ellipse): number;

// @public (undocumented)
export function getEllipseRadiusOfAngle(ellipse: Ellipse, angle: number): number;

// @public (undocumented)
export function getFootPoint(point: Position, line: GeneralFormLine): Position;

// @public (undocumented)
export function getGroupGraphics(children: Graphic[], matrix?: Matrix, options?: Partial<{
    translate: Position;
    base: Position;
    angle: number;
    rotation: number;
    matrix: Matrix;
    opacity: number;
}>, opacity?: number): ({
    matrix: Matrix | undefined;
    opacity: number;
    type: "lines" | "triangles" | "line strip" | "triangle strip" | "triangle fan";
    points: number[];
    color?: [number, number, number, number] | undefined;
    colors?: number[] | undefined;
    pattern?: PatternGraphic | undefined;
} | {
    matrix: Matrix | undefined;
    opacity: number;
    type: "texture";
    color?: [number, number, number, number] | undefined;
    x: number;
    y: number;
    width?: number | undefined;
    height?: number | undefined;
    src: ImageBitmap | ImageData;
    pattern?: PatternGraphic | undefined;
})[];

// @public (undocumented)
export function getImageGraphic(url: string, x: number, y: number, width: number, height: number, rerender: () => void, options?: Partial<{
    opacity: number;
    crossOrigin: "anonymous" | "use-credentials" | "";
}>): Graphic | undefined;

// @public (undocumented)
export function getLinearDimensionGeometries(content: LinearDimension, dimensionStyle: {
    margin: number;
    arrowAngle: number;
    arrowSize: number;
}, getTextPosition: (content: LinearDimension) => {
    textPosition: Position;
    textRotation: number;
    size?: Size;
    text: string;
}): {
    lines: [Position, Position][];
    regions: {
        points: Position[];
        lines: [Position, Position][];
    }[];
    points: Position[];
    bounding: TwoPointsFormRegion | undefined;
};

// @public (undocumented)
export function getLinearDimensionTextPosition(content: LinearDimension, margin: number, getTextSize: (font: string, text: string) => Size | undefined): {
    text: string;
    textPosition: Position;
    size: Size | undefined;
    textRotation: number;
};

// @public (undocumented)
export function getLineCircleIntersectionPoints(start: Position, end: Position, { x, y, r }: Circle): {
    x: number;
    y: number;
}[];

// @public (undocumented)
export function getLineSegmentCircleIntersectionPoints(start: Position, end: Position, circle: Circle): {
    x: number;
    y: number;
}[];

// @public (undocumented)
export function getParallelLinesByDistance(line: GeneralFormLine, distance: number): [GeneralFormLine, GeneralFormLine];

// Warning: (ae-forgotten-export) The symbol "StrokeStyle" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FillStyle" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function getPathGraphics(points: Position[][], strokeWidthScale: number, options?: Partial<StrokeStyle & PathLineStyleOptions & FillStyle & {
    closed: boolean;
}>): Graphic[];

// @public (undocumented)
export function getPerpendicular(point: Position, line: GeneralFormLine): {
    a: number;
    b: number;
    c: number;
};

// @public (undocumented)
export function getPointAndLineSegmentMinimumDistance(position: Position, point1: Position, point2: Position): number;

// @public (undocumented)
export function getPointAndLineSegmentNearestPointAndDistance(position: Position, point1: Position, point2: Position): {
    point: Position;
    distance: number;
};

// @public (undocumented)
export function getPointAndRegionMaximumDistance(position: Position, region: TwoPointsFormRegion): number;

// @public (undocumented)
export function getPointAndRegionMinimumDistance(position: Position, region: TwoPointsFormRegion): number;

// @public (undocumented)
export function getPointByLengthAndAngle(startPoint: Position, length: number, angle: number): {
    x: number;
    y: number;
};

// @public (undocumented)
export function getPointByLengthAndDirection(startPoint: Position, length: number, directionPoint: Position): {
    x: number;
    y: number;
};

// @public (undocumented)
export function getPointByLengthAndDirectionSafely(startPoint: Position, length: number, directionPoint: Position): {
    x: number;
    y: number;
} | undefined;

// @public (undocumented)
export function getPointsBounding(points: Position[]): TwoPointsFormRegion | undefined;

// @public
export function getPointSideOfLine(point: Position, line: GeneralFormLine): number;

// @public (undocumented)
export function getPolygonPoints(point: Position, center: Position, sides: number, toEdge?: boolean): Position[];

// @public (undocumented)
export function getPolylineTriangles(points: Position[], width: number, lineCapWithClosed?: true | 'butt' | 'round' | 'square', lineJoinWithLimit?: 'round' | 'bevel' | number): number[];

// @public (undocumented)
export function getQuadraticCurvePoints(p1: Position, p2: Position, p3: Position, segmentCount: number): Position[];

// @public (undocumented)
export function getRadialDimensionGeometries(content: RadialDimension, circle: Circle, dimensionStyle: {
    margin: number;
    arrowAngle: number;
    arrowSize: number;
}, getTextPosition: (content: RadialDimension, circle: Circle) => {
    textPosition: Position;
    textRotation: number;
    size?: Size;
    text: string;
}): {
    lines: [Position, Position][];
    regions: {
        points: Position[];
        lines: [Position, Position][];
    }[];
    points: Position[];
    bounding: TwoPointsFormRegion | undefined;
};

// @public (undocumented)
export function getRadialDimensionTextPosition(content: RadialDimension, circle: Circle, margin: number, getTextSize: (font: string, text: string) => Size | undefined): {
    textPosition: Position;
    textRotation: number;
    size: Size | undefined;
    text: string;
};

// @public (undocumented)
export function getRegion(p1: Position, p2: Position): Region;

// @public (undocumented)
export function getResizeCursor(rotate: number, direction: ResizeDirection): string;

// @public (undocumented)
export function getResizeOffset(startPosition: Position, cursorPosition: Position, direction: ResizeDirection, rotate?: number, isCenteredScaling?: boolean, ratio?: number, parentRotate?: number): {
    x: number;
    y: number;
    width: number;
    height: number;
} | undefined;

// @public (undocumented)
export function getRotateTransform(x: number, y: number, options?: Partial<{
    angle: number;
    rotation: number;
}>): string | undefined;

// @public (undocumented)
export function getSymmetryPoint(p: Position, { a, b, c }: GeneralFormLine): {
    x: number;
    y: number;
};

// @public (undocumented)
export function getTextGraphic(x: number, y: number, text: string, fill: number | PatternGraphic | undefined, fontSize: number, fontFamily: string, options?: Partial<StrokeStyle & {
    fontWeight: React.CSSProperties['fontWeight'];
    fontStyle: React.CSSProperties['fontStyle'];
    fillOpacity?: number;
    cacheKey: object;
}>): Graphic | undefined;

// @public (undocumented)
export function getTextSize(font: string, text: string): {
    width: number;
    height: number;
} | undefined;

// @public (undocumented)
export function getThreePointsCircle(startPosition: Position, middlePosition: Position, endPosition: Position): {
    r: number;
    x: number;
    y: number;
};

// @public (undocumented)
export function getTwoCircleIntersectionPoints({ x: x1, y: y1, r: r1 }: Circle, { x: x2, y: y2, r: r2 }: Circle): Position[];

// @public (undocumented)
export function getTwoGeneralFormLinesIntersectionPoint(p1: GeneralFormLine, p2: GeneralFormLine): {
    x: number;
    y: number;
} | undefined;

// @public (undocumented)
export function getTwoLineSegmentsIntersectionPoint(p1Start: Position, p1End: Position, p2Start: Position, p2End: Position): {
    x: number;
    y: number;
} | undefined;

// @public (undocumented)
export function getTwoLinesIntersectionPoint(p1Start: Position, p1End: Position, p2Start: Position, p2End: Position): {
    x: number;
    y: number;
} | undefined;

// @public (undocumented)
export function getTwoNumberCenter(p1: number, p2: number): number;

// @public (undocumented)
export function getTwoNumbersDistance(n1: number, n2: number): number;

// @public (undocumented)
export function getTwoPointCenter(p1: Position, p2: Position): {
    x: number;
    y: number;
};

// @public (undocumented)
export function getTwoPointsDistance(point1: Position, point2: Position): number;

// @public (undocumented)
export function getTwoPointsFormRegion(p1: Position, p2: Position): TwoPointsFormRegion;

// @public (undocumented)
export interface GradientStop {
    // (undocumented)
    color: number;
    // (undocumented)
    offset: number;
    // (undocumented)
    opacity?: number;
}

// Warning: (ae-forgotten-export) The symbol "LineOrTriangleGraphic" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TextureGraphic" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Graphic = (LineOrTriangleGraphic | TextureGraphic) & {
    matrix?: Matrix;
    pattern?: PatternGraphic;
    opacity?: number;
};

// @public (undocumented)
export function isBetween(target: number, a: number, b: number): boolean;

// @public (undocumented)
export const isMacKeyboard: boolean;

// @public (undocumented)
export function isSamePath<T extends SelectPath = SelectPath>(path1: T | undefined, path2: T | undefined): boolean;

// @public (undocumented)
export function isSamePoint(p1: Position, p2: Position): boolean;

// @public (undocumented)
export function isSelected<T extends SelectPath = SelectPath>(value: T, selected: readonly T[]): boolean;

// @public (undocumented)
export function isZero(value: number): boolean;

// @public (undocumented)
export function iterateIntersectionPoints<T>(content1: T, content2: T, contents: readonly T[], getModel: (content: T) => {
    getCircle?: (content: T) => {
        circle: Circle;
    };
    getGeometries?: (content: T, contents: readonly T[]) => {
        lines: [Position, Position][];
    };
} | undefined): Generator<Position, void, undefined>;

// @public (undocumented)
export function iteratePolygonLines(points: Position[]): Generator<[Position, Position], void, unknown>;

// @public (undocumented)
export function iteratePolylineLines(points: Position[]): Generator<[Position, Position], void, unknown>;

// @public (undocumented)
export interface LastRenderingLines {
    // (undocumented)
    dashArray?: number[];
    // (undocumented)
    line: Position[][];
    // (undocumented)
    strokeColor: number;
    // (undocumented)
    strokeWidth: number;
}

// @public (undocumented)
export interface LinearDimension extends TextStyle {
    // (undocumented)
    direct?: boolean;
    // (undocumented)
    p1: Position;
    // (undocumented)
    p2: Position;
    // (undocumented)
    position: Position;
}

// @public (undocumented)
export interface LinearGradient {
    // (undocumented)
    end: Position;
    // (undocumented)
    start: Position;
    // (undocumented)
    stops: GradientStop[];
}

// @public (undocumented)
export function lineIntersectWithTwoPointsFormRegion(p1: Position, p2: Position, region: TwoPointsFormRegion): boolean;

// @public (undocumented)
export const m3: {
    projection(width: number, height: number): Matrix;
    identity(): Matrix;
    translation(tx: number, ty: number): Matrix;
    rotation(angleInRadians: number): Matrix;
    scaling(sx: number, sy: number): Matrix;
    multiply(a: Matrix, b: Matrix): Matrix;
    getTransform(m: Matrix): readonly [number, number, number, number, number, number];
};

// @public (undocumented)
export class MapCache2<TKey1, TKey2, TValue> {
    // (undocumented)
    get(key1: TKey1, key2: TKey2, func: () => TValue): TValue;
}

// @public (undocumented)
export type Matrix = readonly [number, number, number, number, number, number, number, number, number];

// @public (undocumented)
export function metaKeyIfMacElseCtrlKey(e: React_2.KeyboardEvent | KeyboardEvent): boolean;

// @public (undocumented)
export function normalizeAngleInRange(angle: number, range: AngleRange): number;

// @public (undocumented)
export function normalizeAngleRange(content: AngleRange): void;

// @public (undocumented)
export interface PartStyle {
    // (undocumented)
    color: number;
    // (undocumented)
    index: number;
    // (undocumented)
    opacity?: number;
}

// @public (undocumented)
export type PathCommand = {
    type: 'move';
    to: Position;
} | {
    type: 'line';
    to: Position;
} | {
    type: 'arc';
    from: Position;
    to: Position;
    radius: number;
} | {
    type: 'bezierCurve';
    cp1: Position;
    cp2: Position;
    to: Position;
} | {
    type: 'quadraticCurve';
    cp: Position;
    to: Position;
} | {
    type: 'close';
};

// @public (undocumented)
export interface PathFillOptions<T> {
    // (undocumented)
    clip: () => T;
    // (undocumented)
    fillColor: number;
    // (undocumented)
    fillLinearGradient: LinearGradient;
    // (undocumented)
    fillOpacity: number;
    // (undocumented)
    fillPattern: Pattern<T>;
    // (undocumented)
    fillRadialGradient: RadialGradient;
}

// @public (undocumented)
export interface PathLineStyleOptions {
    // (undocumented)
    lineCap?: 'butt' | 'round' | 'square';
    // (undocumented)
    lineJoin: 'round' | 'bevel' | 'miter';
    // (undocumented)
    miterLimit: number;
}

// @public (undocumented)
export interface PathOptions<T> extends PathStrokeOptions<T>, PathLineStyleOptions, PathFillOptions<T> {
    // (undocumented)
    closed: boolean;
}

// @public (undocumented)
export interface PathStrokeOptions<T> {
    // (undocumented)
    dashArray: number[];
    // (undocumented)
    dashOffset: number;
    // (undocumented)
    strokeColor: number;
    // (undocumented)
    strokeOpacity: number;
    // (undocumented)
    strokePattern: Pattern<T>;
    // (undocumented)
    strokeWidth: number;
}

// @public (undocumented)
export interface Pattern<T> extends Size {
    // (undocumented)
    pattern: () => T;
}

// @public (undocumented)
export type PatternGraphic = {
    graphics: Graphic[];
} & Partial<Size>;

// @public (undocumented)
export function pointInPolygon({ x, y }: Position, polygon: Position[]): boolean;

// @public (undocumented)
export function pointIsInRegion(point: Position, region: TwoPointsFormRegion): boolean;

// @public (undocumented)
export function pointIsOnLine(p: Position, point1: Position, point2: Position): boolean;

// @public (undocumented)
export function pointIsOnLineSegment(p: Position, point1: Position, point2: Position): boolean;

// @public (undocumented)
export function polarToCartesian(cx: number, cy: number, radius: number, angleInDegrees: number): {
    x: number;
    y: number;
};

// @public (undocumented)
export function polygonToPolyline(points: Position[]): Position[];

// @public (undocumented)
export function PolylineEditBar(props: {
    points: Position[];
    offset?: Position & {
        pointIndexes: number[];
    };
    scale?: number;
    resizeSize?: number;
    isPolygon?: boolean;
    midpointDisabled?: boolean;
    onClick?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, pointIndexes: number[]) => void;
    onMouseDown?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, pointIndexes: number[]) => void;
}): JSX.Element;

// @public (undocumented)
export interface Position {
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export function prependPatchPath(patches: Patch[], path?: SelectPath): Patch[];

// @public (undocumented)
export interface RadialDimension extends TextStyle {
    // (undocumented)
    position: Position;
}

// @public (undocumented)
export interface RadialGradient {
    // (undocumented)
    end: Circle;
    // (undocumented)
    start: Circle;
    // (undocumented)
    stops: GradientStop[];
}

// Warning: (ae-forgotten-export) The symbol "Draw" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const reactCanvasRenderTarget: ReactRenderTarget<Draw_2>;

// @public (undocumented)
export interface ReactRenderTarget<T = JSX.Element> {
    // (undocumented)
    renderArc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, options?: Partial<PathOptions<T> & {
        counterclockwise: boolean;
    }>): T;
    // (undocumented)
    renderCircle(cx: number, cy: number, r: number, options?: Partial<PathOptions<T>>): T;
    // (undocumented)
    renderEllipse(cx: number, cy: number, rx: number, ry: number, options?: Partial<PathOptions<T> & {
        angle: number;
        rotation: number;
    }>): T;
    // (undocumented)
    renderEllipseArc(cx: number, cy: number, rx: number, ry: number, startAngle: number, endAngle: number, options?: Partial<PathOptions<T> & {
        angle: number;
        rotation: number;
        counterclockwise: boolean;
    }>): T;
    // (undocumented)
    renderEmpty(): T;
    // (undocumented)
    renderGroup(children: T[], options?: Partial<{
        translate: Position;
        base: Position;
        angle: number;
        rotation: number;
        matrix: Matrix;
        opacity: number;
    }>): T;
    // (undocumented)
    renderImage(url: string, x: number, y: number, width: number, height: number, options?: Partial<{
        opacity: number;
        crossOrigin: "anonymous" | "use-credentials" | "";
    }>): T;
    // (undocumented)
    renderPath(lines: Position[][], options?: Partial<PathOptions<T>>): T;
    // (undocumented)
    renderPathCommands(pathCommands: PathCommand[], options?: Partial<PathOptions<T>>): T;
    // (undocumented)
    renderPolygon(points: Position[], options?: Partial<PathOptions<T> & {
        skippedLines: number[];
        partsStyles: readonly PartStyle[];
    }>): T;
    // (undocumented)
    renderPolyline(points: Position[], options?: Partial<PathOptions<T> & {
        skippedLines: number[];
        partsStyles: readonly PartStyle[];
    }>): T;
    // (undocumented)
    renderRect(x: number, y: number, width: number, height: number, options?: Partial<PathOptions<T> & {
        angle: number;
        rotation: number;
    }>): T;
    // (undocumented)
    renderResult(children: T[], width: number, height: number, options?: Partial<{
        attributes: Partial<React_3.DOMAttributes<HTMLOrSVGElement> & {
            style: React_3.CSSProperties;
        }>;
        transform: {
            x: number;
            y: number;
            scale: number;
        };
        backgroundColor: number;
        debug: boolean;
        strokeWidthScale: number;
    }>): JSX.Element;
    // (undocumented)
    renderText(x: number, y: number, text: string, fill: number | Pattern<T> | undefined, fontSize: number, fontFamily: string, options?: Partial<PathStrokeOptions<T> & {
        fontWeight: React_3.CSSProperties['fontWeight'];
        fontStyle: React_3.CSSProperties['fontStyle'];
        fillOpacity: number;
        cacheKey: object;
    }>): T;
    // (undocumented)
    type: string;
}

// Warning: (ae-forgotten-export) The symbol "Draw" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const reactSvgRenderTarget: ReactRenderTarget<Draw>;

// Warning: (ae-forgotten-export) The symbol "Draw" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const reactWebglRenderTarget: ReactRenderTarget<Draw_3>;

// @public (undocumented)
export interface Region extends Position, Size {
}

// @public (undocumented)
export class RenderingLinesMerger {
    constructor(flush: (lines: LastRenderingLines) => void);
    // (undocumented)
    flushLast(): void;
    // (undocumented)
    push(line: {
        line: Position[];
        strokeColor: number;
        dashArray?: number[];
        strokeWidth: number;
    }): void;
}

// @public (undocumented)
export function renderPartStyledPolyline<T>(target: ReactRenderTarget<T>, partsStyles: readonly PartStyle[], points: Position[], options?: Partial<PathStrokeOptions<T>>): T;

// @public (undocumented)
export function ResizeBar(props: {
    scale?: number;
    resizeSize?: number;
    directions?: ResizeDirection[];
    rotate?: number;
    onMouseDown?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, direction: ResizeDirection) => void;
    onClick?: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, direction: ResizeDirection) => void;
}): JSX.Element;

// @public (undocumented)
export type ResizeDirection = typeof allDirections[number];

// @public (undocumented)
export function reverseTransformPosition(position: Position, transform: Transform | undefined): Position;

// @public (undocumented)
export function rotatePosition(position: Position, center: Position, rotation: number): Position;

// @public (undocumented)
export function rotatePositionByCenter(position: Position, center: Position, angle: number): Position;

// @public (undocumented)
export function RotationBar(props: {
    scale?: number;
    rotateStickLength?: number;
    rotateCircleSize?: number;
    onMouseDown: React_2.MouseEventHandler<HTMLOrSVGElement>;
}): JSX.Element;

// @public (undocumented)
export function scaleByCursorPosition({ width, height }: Size, scale: number, cursor: Position): {
    setX: (x: number) => number;
    setY: (y: number) => number;
};

// @public (undocumented)
export function Scrollbar(props: {
    value: number;
    type: 'horizontal' | 'vertical';
    contentSize: number;
    containerSize: number;
    onChange: (value: number) => void;
    style?: React_2.CSSProperties;
}): JSX.Element | null;

// @public (undocumented)
export type SelectPath = readonly (string | number)[];

// @public (undocumented)
export function setCanvasLineDash(ctx: CanvasRenderingContext2D, options?: Partial<{
    dashArray: number[];
    dashOffset: number;
}>): void;

// @public (undocumented)
export interface Size {
    // (undocumented)
    height: number;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export type SnapPoint = Position & {
    type: SnapPointType;
};

// @public (undocumented)
export type SnapPointType = typeof allSnapTypes[number];

// @public (undocumented)
export interface TextStyle {
    // (undocumented)
    fontFamily: string;
    // (undocumented)
    fontSize: number;
}

// @public (undocumented)
export interface Transform extends Position {
    // (undocumented)
    center: Position;
    // (undocumented)
    scale: number;
}

// @public (undocumented)
export function twoPointLineToGeneralFormLine(point1: Position, point2: Position): GeneralFormLine;

// @public (undocumented)
export interface TwoPointsFormRegion {
    // (undocumented)
    end: Position;
    // (undocumented)
    start: Position;
}

// @public (undocumented)
export function useCircleArcClickCreate(type: '2 points' | '3 points' | 'center radius' | 'center diameter' | undefined, onEnd: (arc: Arc) => void, options?: Partial<{
    getAngleSnap: (angle: number) => number | undefined;
}>): {
    circle: Circle | undefined;
    arc: Arc | undefined;
    startPosition: Position | undefined;
    middlePosition: Position | undefined;
    cursorPosition: Position | undefined;
    onClick(p: Position): void;
    onMove(p: Position, viewportPosition?: Position): void;
    input: JSX.Element | undefined;
};

// Warning: (ae-forgotten-export) The symbol "EditOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useCircleArcEdit<T = void>(onEnd: () => void, options?: EditOptions): {
    offset: Arc & {
        data?: T | undefined;
    };
    onStart: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, data: EditData<T, {
    type: 'center' | 'start angle' | 'end angle' | 'radius';
    } & Arc>) => void;
    mask: JSX.Element | undefined;
    cursorPosition: Position | undefined;
};

// @public (undocumented)
export function useCircleClickCreate(type: '2 points' | '3 points' | 'center radius' | 'center diameter' | undefined, onEnd: (circle: Circle) => void, options?: Partial<{
    getAngleSnap: (angle: number) => number | undefined;
    message: string;
    onKeyDown: (e: React_2.KeyboardEvent<HTMLInputElement>, text: string, cursorPosition: Position) => void;
}>): {
    circle: Circle | undefined;
    startPosition: Position | undefined;
    middlePosition: Position | undefined;
    cursorPosition: Position | undefined;
    setCursorPosition: React_2.Dispatch<React_2.SetStateAction<Position | undefined>>;
    setInputPosition: React_2.Dispatch<React_2.SetStateAction<Position | undefined>>;
    clearText: () => void;
    onClick(p: Position): void;
    onMove(p: Position, viewportPosition?: Position): void;
    input: JSX.Element | undefined;
};

// @public (undocumented)
export function useCircleEdit<T = void>(onEnd: () => void, options?: EditOptions): {
    cursorPosition: Position | undefined;
    offset: Circle & {
        data?: T | undefined;
    };
    onStart: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, data: EditData<T, {
    type: 'center' | 'edge';
    } & Circle>) => void;
    mask: JSX.Element | undefined;
};

// @public (undocumented)
export function useCursorInput(message: string, onKeyDown?: (e: React_2.KeyboardEvent<HTMLInputElement>, text: string, cursorPosition: Position) => void, options?: Partial<{
    hideIfNoInput: boolean;
    inputStyle: React_2.CSSProperties;
}>): {
    resetInput: () => void;
    cursorPosition: Position | undefined;
    inputPosition: Position | undefined;
    setCursorPosition: React_2.Dispatch<React_2.SetStateAction<Position | undefined>>;
    setInputPosition: React_2.Dispatch<React_2.SetStateAction<Position | undefined>>;
    clearText(): void;
    input: JSX.Element | undefined;
};

// @public (undocumented)
export function useDragMove<T = void>(onDragEnd?: () => void, options?: Partial<{
    scale: number;
    parentRotate: number;
    repeatedly: boolean;
    transform: (p: Position) => Position;
    ignoreLeavingEvent: boolean;
    transformOffset: (p: Position, e?: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>) => Position;
    getAngleSnap: (angle: number) => number | undefined;
}>): {
    offset: Position;
    startPosition: (Position & {
        data?: T | undefined;
    }) | undefined;
    onStart(p: Position, startPosition?: Partial<Position & {
        data: T;
    }>): void;
    mask: JSX.Element | undefined;
};

// @public (undocumented)
export function useDragResize(onDragEnd: () => void, options?: Partial<{
    centeredScaling: boolean | ((e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>) => boolean);
    keepRatio: number | undefined | ((e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>) => number | undefined);
    rotate: number;
    parentRotate: number;
    transform: (p: Position) => Position;
    transformOffset: (p: Region, e?: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, direction?: ResizeDirection) => Region;
    getAngleSnap: (angle: number) => number | undefined;
}>): {
    offset: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    cursorPosition: Position | undefined;
    startPosition: (Position & {
        direction: ResizeDirection;
    }) | undefined;
    onStart(e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, direction: ResizeDirection): void;
    mask: JSX.Element | undefined;
};

// @public (undocumented)
export function useDragRotate(onDragEnd: () => void, options?: Partial<{
    transform: (p: Position) => Position;
    parentRotate: number;
    ignoreLeavingEvent: boolean;
    transformOffset: (p: number, e?: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>) => number;
    getAngleSnap: (angle: number) => number | undefined;
}>): {
    offset: (Position & {
        angle?: number | undefined;
    }) | undefined;
    center: Position | undefined;
    onStart: React_2.Dispatch<React_2.SetStateAction<Position | undefined>>;
    mask: JSX.Element | undefined;
};

// @public (undocumented)
export function useDragSelect<T = void>(onDragEnd: (dragSelectStartPosition: Position & {
    data?: T;
}, dragSelectEndPosition?: Position) => void, square?: boolean | ((e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>) => boolean)): {
    dragSelectStartPosition: (Position & {
        data?: T | undefined;
    }) | undefined;
    onStartSelect(e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, data?: T): void;
    dragSelectMask: JSX.Element | undefined;
};

// @public (undocumented)
export function useEdit<T, TPath extends SelectPath = SelectPath>(onEnd: () => void, getEditPoints?: (content: T) => {
    editPoints: EditPoint<T>[];
    angleSnapStartPoint?: Position;
} | undefined, options?: Partial<{
    scale: number;
    readOnly: boolean;
    getAngleSnap: (angle: number) => number | undefined;
}>): {
    editPoint: (Position & {
        cursor: string;
        update: (content: Draft<T>, props: {
            cursor: Position;
            start: Position;
            scale: number;
        }) => void | {
            assistentContents?: T[] | undefined;
        };
    } & {
        path: TPath;
        angleSnapStartPoint?: Position | undefined;
    }) | undefined;
    getEditAssistentContents<V>(content: T, createRect: (rect: Region) => V): V[];
    updateEditPreview: ((getContentByPath: (path: TPath) => Draft<T> | undefined) => void | {
        assistentContents?: T[] | undefined;
    }) | undefined;
    onEditMove(p: Position, selectedContents: readonly {
        content: T;
        path: TPath;
    }[]): void;
    onEditClick(p: Position): void;
};

// @public (undocumented)
export function useEllipseArcClickCreate(type: 'ellipse center' | 'ellipse endpoint' | undefined, onEnd: (arc: EllipseArc) => void, options?: Partial<{
    getAngleSnap: (angle: number) => number | undefined;
}>): {
    ellipse: Ellipse | undefined;
    ellipseArc: EllipseArc | undefined;
    startPosition: Position | undefined;
    middlePosition: Position | undefined;
    cursorPosition: Position | undefined;
    onClick(p: Position): void;
    onMove(p: Position, viewportPosition?: Position): void;
    input: JSX.Element | undefined;
};

// @public (undocumented)
export function useEllipseArcEdit<T = void>(onEnd: () => void, options?: EditOptions): {
    offset: EllipseArc & {
        data?: T | undefined;
    };
    onStart: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, data: EditData<T, {
    type: 'center' | 'start angle' | 'end angle';
    } & EllipseArc>) => void;
    mask: JSX.Element | undefined;
    cursorPosition: Position | undefined;
};

// @public (undocumented)
export function useEllipseClickCreate(type: 'ellipse center' | 'ellipse endpoint' | undefined, onEnd: (ellipse: Ellipse) => void, options?: Partial<{
    getAngleSnap: (angle: number) => number | undefined;
    message: string;
    onKeyDown: (e: React_2.KeyboardEvent<HTMLInputElement>, text: string, cursorPosition: Position) => void;
}>): {
    ellipse: Ellipse | undefined;
    startPosition: Position | undefined;
    middlePosition: Position | undefined;
    cursorPosition: Position | undefined;
    setCursorPosition: React_2.Dispatch<React_2.SetStateAction<Position | undefined>>;
    setInputPosition: React_2.Dispatch<React_2.SetStateAction<Position | undefined>>;
    clearText: () => void;
    onClick(p: Position): void;
    onMove(p: Position, viewportPosition?: Position): void;
    input: JSX.Element | undefined;
};

// @public (undocumented)
export function useEllipseEdit<T = void>(onEnd: () => void, options?: EditOptions): {
    offset: Ellipse & {
        data?: T | undefined;
    };
    onStart: (e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, data: EditData<T, {
    type: 'center' | 'major axis' | 'minor axis';
    } & Ellipse>) => void;
    mask: JSX.Element | undefined;
    cursorPosition: Position | undefined;
};

// @public (undocumented)
export function useEvent<T>(handler: (e: T) => void): (e: T) => void;

// @public (undocumented)
export function useKey(filter: (e: KeyboardEvent) => boolean, handler: (e: KeyboardEvent) => void, deps?: unknown[]): void;

// @public (undocumented)
export function useLastValidValue<T>(value: T, isValid: (value: T) => boolean, defaultValue?: T): T;

// @public (undocumented)
export function useLineAlignment(delta: number): {
    lineAlignmentX: number | undefined;
    lineAlignmentY: number | undefined;
    changeOffsetByLineAlignment(offset: Region, direction: ResizeDirection, target: Region, xlines: number[], yLines: number[]): void;
    clearLineAlignments(): void;
};

// @public (undocumented)
export function useLineClickCreate(enabled: boolean, onEnd: (line: Position[]) => void, options?: Partial<{
    once: boolean;
    getAngleSnap: (angle: number) => number | undefined;
    getLengthSnap: (angle: number) => number | undefined;
}>): {
    line: Position[] | undefined;
    inputMode: "length" | "angle";
    onClick(p: Position): void;
    onMove(p: Position, viewportPosition?: Position): void;
    input: JSX.Element | undefined;
};

// @public (undocumented)
export function usePartialEdit<T>(content: T, options?: Partial<{
    onEditingContentPathChange: (content: T) => void;
}>): {
    editingContent: T;
    setEditingContentPath: (path: SelectPath | undefined) => void;
    prependPatchPath: (patches: Patch[]) => Patch[];
    getContentByPath<V>(content: V): V;
};

// @public (undocumented)
export function usePatchBasedUndoRedo<T, P>(defaultState: Readonly<T>, operator: P, options?: Partial<{
    onApplyPatchesFromSelf: (patches: Patch[], reversePatches: Patch[]) => void;
    onChange: (data: {
        patches: Patch[];
        oldState: Readonly<T>;
        newState: Readonly<T>;
    }) => void;
}>): {
    state: Readonly<T>;
    applyPatchFromOtherOperators: (patches: Patch[], reversePatches: Patch[], operator: P) => Readonly<T>;
    applyPatchFromSelf: (patches: Patch[], reversePatches: Patch[]) => Readonly<T>;
    setState: (recipe: (draft: WritableDraft<T>) => void) => Readonly<T>;
    canUndo: boolean;
    canRedo: boolean;
    undo: (e?: {
        preventDefault(): void;
    }) => void;
    redo: (e?: {
        preventDefault(): void;
    }) => void;
    stateIndex: number;
};

// @public (undocumented)
export function usePointSnap<T>(enabled: boolean, getIntersectionPoints: (content1: T, content2: T, contents: readonly T[]) => Position[], types: readonly SnapPointType[], getModel: (content: T) => {
    getSnapPoints?: (content: T, contents: readonly T[]) => SnapPoint[];
    getGeometries?: (content: T, contents: readonly T[]) => {
        lines: [Position, Position][];
        bounding?: TwoPointsFormRegion;
    };
    getCircle?: (content: T) => {
        circle: Circle;
        bounding?: TwoPointsFormRegion;
    };
} | undefined, scale?: number, delta?: number): {
    snapPoint: SnapPoint | undefined;
    getSnapAssistentContents<TCircle = T, TRect = T, TPolyline = T>(createCircle: (circle: Circle) => TCircle, createRect: (rect: Region) => TRect, createPolyline: (points: Position[]) => TPolyline): (TCircle | TRect | TPolyline)[];
    getSnapPoint(p: Position, contents: readonly T[], getContentsInRange?: ((region: TwoPointsFormRegion) => readonly T[]) | undefined): Position;
};

// @public (undocumented)
export function usePolygonClickCreate(enabled: boolean, onEnd: (polygon: Position[]) => void, options?: Partial<{
    toEdge: boolean;
    getAngleSnap: (angle: number) => number | undefined;
    setSidesKey: string;
    switchTypeKey: string;
    switchType(): void;
}>): {
    polygon: Position[] | undefined;
    startPosition: Position | undefined;
    cursorPosition: Position | undefined;
    onClick(p: Position): void;
    onMove(p: Position, viewportPosition?: Position): void;
    input: JSX.Element | undefined;
    startSetSides(): void;
};

// @public (undocumented)
export function usePolylineEdit<T = void>(onEnd: () => void, options?: EditOptions): {
    offset: (Position & {
        pointIndexes: number[];
        data?: T | undefined;
    }) | undefined;
    onStart(e: React_2.MouseEvent<HTMLOrSVGElement, MouseEvent>, pointIndexes: number[], data?: T): void;
    mask: JSX.Element | undefined;
    cursorPosition: Position | undefined;
    dragStartPosition: (Position & {
        data: EditData<T, {
        pointIndexes: number[];
        }>;
    }) | undefined;
};

// @public (undocumented)
export function useRegionAlignment(delta: number): {
    regionAlignmentX: number | undefined;
    regionAlignmentY: number | undefined;
    changeOffsetByRegionAlignment(offset: Position, target: Region, regions: Region[]): void;
    clearRegionAlignments(): void;
};

// @public (undocumented)
export function useSelectBeforeOperate<TSelect extends {
    count?: number;
    selectable?: (index: TPath) => boolean;
}, TOperate, TPath extends SelectPath = SelectPath>(defaultOperation: TSelect, executeOperation: (operation: TOperate, selected: readonly TPath[]) => boolean, options?: Partial<UseSelectedOptions<TPath>>): {
    message: string;
    selected: readonly TPath[];
    isSelected: (value: TPath, s?: readonly TPath[]) => boolean;
    addSelection(...value: readonly TPath[]): void;
    setSelected: (...value: readonly (TPath | undefined)[]) => void;
    filterSelection: (selectable?: ((value: TPath) => boolean) | undefined, maxCount?: number | undefined, s?: readonly TPath[]) => {
        result: readonly TPath[];
        needSelect: boolean;
    };
    isSelectable: (path: TPath) => boolean;
    operations: {
        type: 'select';
        select: TSelect;
    } | {
        type: 'operate';
        operate: TOperate;
    } | {
        type: 'select then operate';
        select: TSelect;
        operate: TOperate;
    };
    executeOperation: (operation: TOperate, selected: readonly TPath[]) => boolean;
    startNextOperation: (s?: readonly TPath[]) => void;
    resetOperation: () => void;
    selectBeforeOperate(select: TSelect, operate: TOperate): void;
    operate(operate: TOperate): void;
};

// @public (undocumented)
export function useSelected<T extends SelectPath = SelectPath>(options?: Partial<UseSelectedOptions<T>>): {
    selected: readonly T[];
    filterSelection: (selectable?: ((value: T) => boolean) | undefined, maxCount?: number | undefined, s?: readonly T[]) => {
        result: readonly T[];
        needSelect: boolean;
    };
    isSelected: (value: T, s?: readonly T[]) => boolean;
    addSelection: (value: readonly T[], maxCount?: number | undefined, reachMaxCount?: ((selected: T[]) => void) | undefined, selectable?: ((value: T) => boolean) | undefined) => void;
    setSelected(...value: readonly (T | undefined)[]): void;
};

// @public (undocumented)
export interface UseSelectedOptions<T> {
    // (undocumented)
    maxCount: number;
    // (undocumented)
    onChange: (s: readonly T[]) => void;
}

// @public (undocumented)
export function useUndoRedo<T>(defaultState: T): {
    state: T;
    stateIndex: number;
    setState: (recipe: (draft: WritableDraft<T>) => void) => T;
    canUndo: boolean;
    canRedo: boolean;
    undo: (e?: {
        preventDefault(): void;
    }) => void;
    redo: (e?: {
        preventDefault(): void;
    }) => void;
};

// @public (undocumented)
export function useValueChanged<T>(value: T, callback: (lastValue: T) => true | void): void;

// @public (undocumented)
export function useWheelScroll<T extends HTMLElement>(maxOffsetX?: number, maxOffsetY?: number): {
    ref: React_2.MutableRefObject<T | null>;
    x: number;
    y: number;
    setX: React_2.Dispatch<React_2.SetStateAction<number>>;
    setY: React_2.Dispatch<React_2.SetStateAction<number>>;
};

// @public (undocumented)
export function useWheelZoom<T extends HTMLElement>(options?: Partial<ZoomOptions & {
    onChange(oldScale: number, newScale: number, cursor: Position): void;
}>): {
    ref: React_2.MutableRefObject<T | null>;
    scale: number;
    setScale: React_2.Dispatch<React_2.SetStateAction<number>>;
};

// @public (undocumented)
export function useWindowSize(): {
    width: number;
    height: number;
};

// @public (undocumented)
export function useZoom(value: number, onChange: (value: number) => void, options?: Partial<{
    min: number;
    max: number;
    step: number;
}>): {
    canZoomIn: boolean;
    canZoomOut: boolean;
    zoomIn: (e?: {
        preventDefault(): void;
    }) => void;
    zoomOut: (e?: {
        preventDefault(): void;
    }) => void;
};

// @public (undocumented)
export class WeakmapCache<TKey extends object, TValue> {
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key: TKey, func: () => TValue): TValue;
}

// @public (undocumented)
export class WeakmapCache2<TKey1 extends object, TKey2 extends object, TValue> {
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key1: TKey1, key2: TKey2, func: () => TValue): TValue;
}

// @public (undocumented)
export class WeakmapMap2Cache<TKey1 extends object, TKey2, TKey3, TValue> {
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key1: TKey1, key2: TKey2, key3: TKey3, func: () => TValue): TValue;
}

// @public (undocumented)
export class WeakmapMap3Cache<TKey1 extends object, TKey2, TKey3, TKey4, TValue> {
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key1: TKey1, key2: TKey2, key3: TKey3, key4: TKey4, func: () => TValue): TValue;
}

// @public (undocumented)
export class WeakmapMap4Cache<TKey1 extends object, TKey2, TKey3, TKey4, TKey5, TValue> {
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key1: TKey1, key2: TKey2, key3: TKey3, key4: TKey4, key5: TKey5, func: () => TValue): TValue;
}

// @public (undocumented)
export class WeakmapMapCache<TKey1 extends object, TKey2, TValue> {
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key1: TKey1, key2: TKey2, func: () => TValue): TValue;
}

// @public (undocumented)
export class WeaksetCache<T extends object> {
    // (undocumented)
    add(...values: T[]): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(value: T): boolean;
    // (undocumented)
    has(value: T): boolean;
    // (undocumented)
    get size(): number;
}

// @public (undocumented)
export interface ZoomOptions {
    // (undocumented)
    max: number;
    // (undocumented)
    min: number;
}

// @public (undocumented)
export function zoomToFit(bounding: TwoPointsFormRegion | undefined, { width, height }: Size, center: Position, paddingScale?: number): {
    scale: number;
    x: number;
    y: number;
} | undefined;

// Warnings were encountered during analysis:
//
// dist/nodejs/components/use-edit/use-circle-arc-edit.d.ts:12:5 - (ae-forgotten-export) The symbol "EditData" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
